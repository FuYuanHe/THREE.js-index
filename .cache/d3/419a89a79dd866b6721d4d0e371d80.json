{"id":"shader/deep/fragment.glsl","dependencies":[{"name":"C:\\Users\\hfy83\\Desktop\\THREE.js-index\\package.json","includedInParent":true,"mtime":1677318514776}],"generated":{"js":"module.exports = \"precision lowp float;\\n#define GLSLIFY 1\\n // 定义gpu编译精度\\nvarying vec2 vUv; // 接收顶点着色器传递过来的vUv\\nuniform float uTime;\\n\\n// 随机函数\\nfloat random(vec2 st){\\n     return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\\n}\\n// 旋转函数\\nvec2 rotate(vec2 uv,float rotation ,vec2 mid){\\n     return vec2(\\n          cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,\\n          cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y\\n     );\\n}\\n// 噪音函数\\nfloat noise (in vec2 st) {\\n    vec2 i = floor(st);\\n    vec2 f = fract(st);\\n\\n    // Four corners in 2D of a tile\\n    float a = random(i);\\n    float b = random(i + vec2(1.0, 0.0));\\n    float c = random(i + vec2(0.0, 1.0));\\n    float d = random(i + vec2(1.0, 1.0));\\n\\n    // Smooth Interpolation\\n\\n    // Cubic Hermine Curve.  Same as SmoothStep()\\n    vec2 u = f*f*(3.0-2.0*f);\\n    // u = smoothstep(0.,1.,f);\\n\\n    // Mix 4 coorners percentages\\n    return mix(a, b, u.x) +\\n            (c - a)* u.y * (1.0 - u.x) +\\n            (d - b) * u.x * u.y;\\n}\\n\\nvoid main(){\\n     // 实现彩色\\n     // gl_FragColor = vec4(vUv,1.0,1.0);\\n\\n     // 实现渐变\\n     // gl_FragColor = vec4(vUv.x,vUv.x,vUv.x,1.0);\\n\\n     // 使用变量 黑白渐变从左到右\\n     // float deeps = vUv.x;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 黑白渐变从下到上\\n     // float deeps = vUv.y;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 黑白渐变从上到下\\n     // float deeps = 1.0 - vUv.y;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 黑白巨变\\n     // float deeps = 1.0 - vUv.y*10.0;\\n     // float deeps = vUv.y*10.0;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 取模实现反复的效果 实现百叶窗效果\\n     // float deeps = mod(vUv.y*10.0,1.0);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // step实现反复的效果 实现百叶窗效果.实现黑白百叶窗\\n     // float deeps = step(mod(vUv.y*10.0,1.0),0.4);\\n     // float deeps = step(0.4,mod(vUv.y*10.0,1.0));\\n     // // deeps += step(0.4,mod(vUv.x*10.0,1.0));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 实现条纹堆叠的效果 窗口的效果\\n     // float deeps = step(0.4,mod(vUv.y*10.0,1.0));\\n     // deeps += step(0.4,mod(vUv.x*10.0,1.0));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 条纹相乘或相减 实现条纹或者方块窗户效果，调整‘0.8’\\n     // float deeps = step(0.8,mod(vUv.x*10.0,1.0));\\n     // deeps -= step(0.8,mod(vUv.y*10.0,1.0));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 两个堆叠条纹实现7字形的图案\\n     // float deeps1 = step(0.4,mod(vUv.x*10.0,1.0)) * step(0.8,mod(vUv.y*10.0,1.0));\\n     // float deeps2 = step(0.4,mod(vUv.y*10.0,1.0)) * step(0.8,mod(vUv.x*10.0,1.0));\\n     // float deeps = deeps1 + deeps2; // deeps最后也是一个0-1的值\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 得到炫彩图形\\n     // float deeps1 = step(0.4,mod((vUv.x) * 10.0,1.0)) * step(0.8,mod(vUv.y*10.0,1.0));\\n     // float deeps2 = step(0.4,mod((vUv.y) * 10.0,1.0)) * step(0.8,mod(vUv.x*10.0,1.0));\\n     // float deeps = deeps1 + deeps2; // deeps最后也是一个0-1的值\\n     // gl_FragColor = vec4(vUv,1,deeps);\\n\\n     // 得到炫彩可移动图形\\n     // float deeps1 = step(0.4,mod((vUv.x +uTime*0.1) * 10.0,1.0)) * step(0.8,mod((vUv.y)*10.0,1.0));\\n     // float deeps2 = step(0.4,mod((vUv.y +uTime*0.1) * 10.0,1.0)) * step(0.8,mod((vUv.x)*10.0,1.0));\\n     // float deeps = deeps1 + deeps2; // deeps最后也是一个0-1的值\\n     // gl_FragColor = vec4(vUv,1,deeps);\\n\\n          // 得到炫彩可整体移动图形\\n     // float deeps1 = step(0.4,mod((vUv.x +uTime*0.1) * 10.0,1.0)) * step(0.8,mod((vUv.y +uTime*0.1)*10.0,1.0));\\n     // float deeps2 = step(0.4,mod((vUv.y +uTime*0.1) * 10.0,1.0)) * step(0.8,mod((vUv.x +uTime*0.1)*10.0,1.0));\\n     // float deeps = deeps1 + deeps2; // deeps最后也是一个0-1的值\\n     // gl_FragColor = vec4(vUv,1,deeps);\\n\\n     // 得到可移动的T字形\\n     // float deeps1 = step(0.4,mod((vUv.x +uTime*0.1) * 10.0-0.2,1.0)) * step(0.8,mod((vUv.y +uTime*0.1)*10.0,1.0));\\n     // float deeps2 = step(0.4,mod((vUv.y +uTime*0.1) * 10.0,1.0)) * step(0.8,mod((vUv.x +uTime*0.1)*10.0,1.0));\\n     // float deeps = deeps1 + deeps2; // deeps最后也是一个0-1的值\\n     // gl_FragColor = vec4(vUv,1,deeps);\\n\\n     // 利用绝对值把负数消掉\\n     // float deeps = abs(vUv.x-0.5);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 取较小值，得到十字\\n     // float deeps = min(abs(vUv.x-0.5),abs(vUv.y-0.5));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 取最大值 得到黑x\\n     // float deeps = max(abs(vUv.x-0.5),abs(vUv.y-0.5));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 结合step，得到框或者一个大正方形\\n     // float deeps = step(max(abs(vUv.x-0.5),abs(vUv.y-0.5)),0.3);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 尝试floor实现波纹效果\\n     // float deeps = 1.0-(floor(vUv.y*10.0)/10.0);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 得到渐变格子\\n     // float deeps =(ceil(vUv.y*10.0)/10.0) *(ceil(vUv.x*10.0)/10.0) ;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 设置随机效果\\n     // float deeps = random(vUv);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 设置随机加格子 马赛克效果 \\n     // float deeps =(ceil(vUv.y*10.0)/10.0) *(ceil(vUv.x*10.0)/10.0) ;\\n     // deeps = random(vec2(deeps,deeps));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 使用length\\n     // float deeps = length(vUv);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 使用distance 计算两个向量的距离\\n     // float deeps = distance(vUv,vec2(0.5,0.5));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 使用distance 实现星星点灯的效果\\n     // float deeps = 0.15/distance(vUv,vec2(0.5,0.5))-1.0;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,deeps);\\n\\n     // 星星上升效果,星星拉扁\\n     // float deeps = 0.15/distance(vec2(vUv.x,(vUv.y-0.5)*5.0),vec2(0.5,0.5))-1.0;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 实现十字交叉发光星星\\n     // float deeps = 0.15/distance(vec2(vUv.x,(vUv.y-0.5)*5.0+0.5),vec2(0.5,0.5))-1.0;\\n     // // deeps *= 0.15/distance(vec2(vUv.y,(vUv.x-0.5)*5.0+0.5),vec2(0.5,0.5))-1.0;\\n     // deeps += 0.15/distance(vec2(vUv.y,(vUv.x-0.5)*5.0+0.5),vec2(0.5,0.5))-1.0;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,deeps);\\n\\n     // 实现选装的飞镖\\n     // vec2 rotateUv = rotate(vUv,uTime*10.0,vec2(0.5));\\n     // float deeps = 0.15/distance(vec2(rotateUv.x,(rotateUv.y-0.5)*5.0+0.5),vec2(0.5,0.5))-1.0;\\n     // deeps += 0.15/distance(vec2(rotateUv.y,(rotateUv.x-0.5)*5.0+0.5),vec2(0.5,0.5))-1.0;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,deeps);\\n\\n     // 绘制一个圆 和反圆\\n     // float deeps =  step(0.5,distance(vUv,vec2(0.5,0.5))+0.25);\\n     // float deeps =  step(distance(vUv,vec2(0.5,0.5))+0.25,0.5);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 实现圆环效果1\\n     // float deeps =  step(0.5,distance(vUv,vec2(0.5,0.5)) + 0.35);\\n     // deeps *= 1.0-(step(0.5,distance(vUv,vec2(0.5,0.5)) + 0.15));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 实现圆环效果2\\n     // float deeps = abs(distance(vUv,vec2(0.5,0.5)) - 0.35);\\n\\n     // 实现圆环效果3\\n     // float deeps = step(0.1,abs(distance(vUv,vec2(0.5,0.5)) - 0.25));\\n     \\n     // 实现随意图形\\n     // vec2 waveUv  = vec2 (\\n     //      vUv.x + sin(vUv.y*30.0)*0.1,\\n     //      vUv.y + sin(vUv.x*30.0)*0.1\\n     // );\\n     // float deeps = step(abs(distance(waveUv,vec2(0.5,0.5)) - 0.25),0.01);\\n\\n     // 根据角度显示视图\\n     // float deeps = atan(vUv.x,vUv.y);\\n\\n     // 根据角度实现螺旋渐变，用在雷达图,颜色从深到浅正好一圈\\n     // float deep = atan(vUv.x-0.5,vUv.y-0.5);\\n     // float deeps = (deep+3.14)/6.28;\\n\\n     // 实现雷达扫射，在之前的基础之上增加圆型图\\n     // float deep = atan(vUv.x-0.5,vUv.y-0.5);\\n     // float deeps = (deep+3.14)/6.28;\\n     // float alpha = 1.0 - step(0.5,distance(vUv,vec2(0.5,0.5)));\\n\\n     // 实现雷达动态旋转\\n     // vec2 rotateUv = rotate(vUv,-uTime*5.0,vec2(0.5));\\n     // float deep = atan(rotateUv.x-0.5,rotateUv.y-0.5);\\n     // float deeps = (deep+3.14)/6.28;\\n     // float alpha = 1.0 - step(0.5,distance(vUv,vec2(0.5)));\\n\\n     // 做万花筒的效果\\n     // vec2 rotateUv = rotate(vUv,-uTime*2.0,vec2(0.5));\\n     // float deep = atan(rotateUv.x-0.5,rotateUv.y-0.5)/6.28;\\n     // float deeps = mod(deep*10.0,1.0);\\n     float alpha = 1.0 - step(0.5,distance(vUv,vec2(0.5)));\\n\\n     // 黑白万花筒\\n     // vec2 rotateUv = rotate(vUv,-uTime*2.0,vec2(0.5));\\n     // float deep = atan(vUv.x-0.5,vUv.y-0.5)/6.28;\\n     // float deeps = sin(deep*100.0);\\n\\n     // 噪声质感\\n     float deep = noise(vUv*50.0);\\n\\n     // 配合step实现黑白\\n     // float deeps = step(0.4,deep);\\n\\n     // 实现发光效果（尝试），这个噪声函数实现不了\\n     float deeps = 1.0 - abs(deep);\\n\\n     gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n}\";"},"sourceMaps":{"js":{"mappings":[{"generated":{"line":1,"column":0},"source":"shader/deep/fragment.glsl","original":{"line":1,"column":0},"name":"module"},{"generated":{"line":1,"column":6},"source":"shader/deep/fragment.glsl","original":{"line":1,"column":6}},{"generated":{"line":1,"column":7},"source":"shader/deep/fragment.glsl","original":{"line":1,"column":7},"name":"exports"},{"generated":{"line":1,"column":14},"source":"shader/deep/fragment.glsl","original":{"line":1,"column":14}},{"generated":{"line":1,"column":17},"source":"shader/deep/fragment.glsl","original":{"line":1,"column":15}},{"generated":{"line":1,"column":8511},"source":"shader/deep/fragment.glsl","original":{"line":1,"column":8509}}],"sources":{"shader/deep/fragment.glsl":"module.exports=\"precision lowp float;\\n#define GLSLIFY 1\\n // 定义gpu编译精度\\nvarying vec2 vUv; // 接收顶点着色器传递过来的vUv\\nuniform float uTime;\\n\\n// 随机函数\\nfloat random(vec2 st){\\n     return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\\n}\\n// 旋转函数\\nvec2 rotate(vec2 uv,float rotation ,vec2 mid){\\n     return vec2(\\n          cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,\\n          cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y\\n     );\\n}\\n// 噪音函数\\nfloat noise (in vec2 st) {\\n    vec2 i = floor(st);\\n    vec2 f = fract(st);\\n\\n    // Four corners in 2D of a tile\\n    float a = random(i);\\n    float b = random(i + vec2(1.0, 0.0));\\n    float c = random(i + vec2(0.0, 1.0));\\n    float d = random(i + vec2(1.0, 1.0));\\n\\n    // Smooth Interpolation\\n\\n    // Cubic Hermine Curve.  Same as SmoothStep()\\n    vec2 u = f*f*(3.0-2.0*f);\\n    // u = smoothstep(0.,1.,f);\\n\\n    // Mix 4 coorners percentages\\n    return mix(a, b, u.x) +\\n            (c - a)* u.y * (1.0 - u.x) +\\n            (d - b) * u.x * u.y;\\n}\\n\\nvoid main(){\\n     // 实现彩色\\n     // gl_FragColor = vec4(vUv,1.0,1.0);\\n\\n     // 实现渐变\\n     // gl_FragColor = vec4(vUv.x,vUv.x,vUv.x,1.0);\\n\\n     // 使用变量 黑白渐变从左到右\\n     // float deeps = vUv.x;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 黑白渐变从下到上\\n     // float deeps = vUv.y;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 黑白渐变从上到下\\n     // float deeps = 1.0 - vUv.y;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 黑白巨变\\n     // float deeps = 1.0 - vUv.y*10.0;\\n     // float deeps = vUv.y*10.0;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 取模实现反复的效果 实现百叶窗效果\\n     // float deeps = mod(vUv.y*10.0,1.0);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // step实现反复的效果 实现百叶窗效果.实现黑白百叶窗\\n     // float deeps = step(mod(vUv.y*10.0,1.0),0.4);\\n     // float deeps = step(0.4,mod(vUv.y*10.0,1.0));\\n     // // deeps += step(0.4,mod(vUv.x*10.0,1.0));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 实现条纹堆叠的效果 窗口的效果\\n     // float deeps = step(0.4,mod(vUv.y*10.0,1.0));\\n     // deeps += step(0.4,mod(vUv.x*10.0,1.0));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 条纹相乘或相减 实现条纹或者方块窗户效果，调整‘0.8’\\n     // float deeps = step(0.8,mod(vUv.x*10.0,1.0));\\n     // deeps -= step(0.8,mod(vUv.y*10.0,1.0));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 两个堆叠条纹实现7字形的图案\\n     // float deeps1 = step(0.4,mod(vUv.x*10.0,1.0)) * step(0.8,mod(vUv.y*10.0,1.0));\\n     // float deeps2 = step(0.4,mod(vUv.y*10.0,1.0)) * step(0.8,mod(vUv.x*10.0,1.0));\\n     // float deeps = deeps1 + deeps2; // deeps最后也是一个0-1的值\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n\\n     // 得到炫彩图形\\n     // float deeps1 = step(0.4,mod((vUv.x) * 10.0,1.0)) * step(0.8,mod(vUv.y*10.0,1.0));\\n     // float deeps2 = step(0.4,mod((vUv.y) * 10.0,1.0)) * step(0.8,mod(vUv.x*10.0,1.0));\\n     // float deeps = deeps1 + deeps2; // deeps最后也是一个0-1的值\\n     // gl_FragColor = vec4(vUv,1,deeps);\\n\\n     // 得到炫彩可移动图形\\n     // float deeps1 = step(0.4,mod((vUv.x +uTime*0.1) * 10.0,1.0)) * step(0.8,mod((vUv.y)*10.0,1.0));\\n     // float deeps2 = step(0.4,mod((vUv.y +uTime*0.1) * 10.0,1.0)) * step(0.8,mod((vUv.x)*10.0,1.0));\\n     // float deeps = deeps1 + deeps2; // deeps最后也是一个0-1的值\\n     // gl_FragColor = vec4(vUv,1,deeps);\\n\\n          // 得到炫彩可整体移动图形\\n     // float deeps1 = step(0.4,mod((vUv.x +uTime*0.1) * 10.0,1.0)) * step(0.8,mod((vUv.y +uTime*0.1)*10.0,1.0));\\n     // float deeps2 = step(0.4,mod((vUv.y +uTime*0.1) * 10.0,1.0)) * step(0.8,mod((vUv.x +uTime*0.1)*10.0,1.0));\\n     // float deeps = deeps1 + deeps2; // deeps最后也是一个0-1的值\\n     // gl_FragColor = vec4(vUv,1,deeps);\\n\\n     // 得到可移动的T字形\\n     // float deeps1 = step(0.4,mod((vUv.x +uTime*0.1) * 10.0-0.2,1.0)) * step(0.8,mod((vUv.y +uTime*0.1)*10.0,1.0));\\n     // float deeps2 = step(0.4,mod((vUv.y +uTime*0.1) * 10.0,1.0)) * step(0.8,mod((vUv.x +uTime*0.1)*10.0,1.0));\\n     // float deeps = deeps1 + deeps2; // deeps最后也是一个0-1的值\\n     // gl_FragColor = vec4(vUv,1,deeps);\\n\\n     // 利用绝对值把负数消掉\\n     // float deeps = abs(vUv.x-0.5);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 取较小值，得到十字\\n     // float deeps = min(abs(vUv.x-0.5),abs(vUv.y-0.5));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 取最大值 得到黑x\\n     // float deeps = max(abs(vUv.x-0.5),abs(vUv.y-0.5));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 结合step，得到框或者一个大正方形\\n     // float deeps = step(max(abs(vUv.x-0.5),abs(vUv.y-0.5)),0.3);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 尝试floor实现波纹效果\\n     // float deeps = 1.0-(floor(vUv.y*10.0)/10.0);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 得到渐变格子\\n     // float deeps =(ceil(vUv.y*10.0)/10.0) *(ceil(vUv.x*10.0)/10.0) ;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 设置随机效果\\n     // float deeps = random(vUv);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 设置随机加格子 马赛克效果 \\n     // float deeps =(ceil(vUv.y*10.0)/10.0) *(ceil(vUv.x*10.0)/10.0) ;\\n     // deeps = random(vec2(deeps,deeps));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 使用length\\n     // float deeps = length(vUv);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 使用distance 计算两个向量的距离\\n     // float deeps = distance(vUv,vec2(0.5,0.5));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 使用distance 实现星星点灯的效果\\n     // float deeps = 0.15/distance(vUv,vec2(0.5,0.5))-1.0;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,deeps);\\n\\n     // 星星上升效果,星星拉扁\\n     // float deeps = 0.15/distance(vec2(vUv.x,(vUv.y-0.5)*5.0),vec2(0.5,0.5))-1.0;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 实现十字交叉发光星星\\n     // float deeps = 0.15/distance(vec2(vUv.x,(vUv.y-0.5)*5.0+0.5),vec2(0.5,0.5))-1.0;\\n     // // deeps *= 0.15/distance(vec2(vUv.y,(vUv.x-0.5)*5.0+0.5),vec2(0.5,0.5))-1.0;\\n     // deeps += 0.15/distance(vec2(vUv.y,(vUv.x-0.5)*5.0+0.5),vec2(0.5,0.5))-1.0;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,deeps);\\n\\n     // 实现选装的飞镖\\n     // vec2 rotateUv = rotate(vUv,uTime*10.0,vec2(0.5));\\n     // float deeps = 0.15/distance(vec2(rotateUv.x,(rotateUv.y-0.5)*5.0+0.5),vec2(0.5,0.5))-1.0;\\n     // deeps += 0.15/distance(vec2(rotateUv.y,(rotateUv.x-0.5)*5.0+0.5),vec2(0.5,0.5))-1.0;\\n     // gl_FragColor = vec4(deeps,deeps,deeps,deeps);\\n\\n     // 绘制一个圆 和反圆\\n     // float deeps =  step(0.5,distance(vUv,vec2(0.5,0.5))+0.25);\\n     // float deeps =  step(distance(vUv,vec2(0.5,0.5))+0.25,0.5);\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 实现圆环效果1\\n     // float deeps =  step(0.5,distance(vUv,vec2(0.5,0.5)) + 0.35);\\n     // deeps *= 1.0-(step(0.5,distance(vUv,vec2(0.5,0.5)) + 0.15));\\n     // gl_FragColor = vec4(deeps,deeps,deeps,1);\\n\\n     // 实现圆环效果2\\n     // float deeps = abs(distance(vUv,vec2(0.5,0.5)) - 0.35);\\n\\n     // 实现圆环效果3\\n     // float deeps = step(0.1,abs(distance(vUv,vec2(0.5,0.5)) - 0.25));\\n     \\n     // 实现随意图形\\n     // vec2 waveUv  = vec2 (\\n     //      vUv.x + sin(vUv.y*30.0)*0.1,\\n     //      vUv.y + sin(vUv.x*30.0)*0.1\\n     // );\\n     // float deeps = step(abs(distance(waveUv,vec2(0.5,0.5)) - 0.25),0.01);\\n\\n     // 根据角度显示视图\\n     // float deeps = atan(vUv.x,vUv.y);\\n\\n     // 根据角度实现螺旋渐变，用在雷达图,颜色从深到浅正好一圈\\n     // float deep = atan(vUv.x-0.5,vUv.y-0.5);\\n     // float deeps = (deep+3.14)/6.28;\\n\\n     // 实现雷达扫射，在之前的基础之上增加圆型图\\n     // float deep = atan(vUv.x-0.5,vUv.y-0.5);\\n     // float deeps = (deep+3.14)/6.28;\\n     // float alpha = 1.0 - step(0.5,distance(vUv,vec2(0.5,0.5)));\\n\\n     // 实现雷达动态旋转\\n     // vec2 rotateUv = rotate(vUv,-uTime*5.0,vec2(0.5));\\n     // float deep = atan(rotateUv.x-0.5,rotateUv.y-0.5);\\n     // float deeps = (deep+3.14)/6.28;\\n     // float alpha = 1.0 - step(0.5,distance(vUv,vec2(0.5)));\\n\\n     // 做万花筒的效果\\n     // vec2 rotateUv = rotate(vUv,-uTime*2.0,vec2(0.5));\\n     // float deep = atan(rotateUv.x-0.5,rotateUv.y-0.5)/6.28;\\n     // float deeps = mod(deep*10.0,1.0);\\n     float alpha = 1.0 - step(0.5,distance(vUv,vec2(0.5)));\\n\\n     // 黑白万花筒\\n     // vec2 rotateUv = rotate(vUv,-uTime*2.0,vec2(0.5));\\n     // float deep = atan(vUv.x-0.5,vUv.y-0.5)/6.28;\\n     // float deeps = sin(deep*100.0);\\n\\n     // 噪声质感\\n     float deep = noise(vUv*50.0);\\n\\n     // 配合step实现黑白\\n     // float deeps = step(0.4,deep);\\n\\n     // 实现发光效果（尝试），这个噪声函数实现不了\\n     float deeps = 1.0 - abs(deep);\\n\\n     gl_FragColor = vec4(deeps,deeps,deeps,1.0);\\n}\";"},"lineCount":null}},"error":null,"hash":"4915dbc816929e550c9d1962c420a7ce","cacheData":{"env":{}}}